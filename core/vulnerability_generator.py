# vulnerability_generator.py
# 基於大型語言模型的RWA智能合約安全檢核框架 - 漏洞生成器模組

import re
import json
import logging
import hashlib
import numpy as np
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple, Set
from dataclasses import dataclass, asdict
from enum import Enum
from collections import defaultdict, Counter

# 配置日誌
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    """智能合約漏洞類型枚舉"""
    REENTRANCY = "重入攻擊"
    INTEGER_OVERFLOW = "整數溢位"
    ACCESS_CONTROL = "存取控制"
    TIMESTAMP_DEPENDENCY = "時間戳依賴"
    PRICE_MANIPULATION = "價格操縱"
    COMPLIANCE_VIOLATION = "合規性違反"
    ASSET_VERIFICATION = "資產驗證"
    CROSS_CHAIN_BRIDGE = "跨鏈橋接"
    UNCHECKED_CALL = "未檢查的外部調用"
    DENIAL_OF_SERVICE = "拒絕服務攻擊"
    FRONT_RUNNING = "搶跑攻擊"
    FLASH_LOAN = "閃電貸攻擊"
    ORACLE_MANIPULATION = "預言機操縱"
    GOVERNANCE_ATTACK = "治理攻擊"
    SANDWICH_ATTACK = "夾子攻擊"
    MEV_ATTACK = "MEV攻擊"
    LIQUIDITY_DRAIN = "流動性枯竭"
    TOKEN_INFLATION = "代幣通脹攻擊"

class SeverityLevel(Enum):
    """嚴重性等級"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

class ConfidenceLevel(Enum):
    """置信度等級"""
    VERY_HIGH = "VERY_HIGH"  # 95%+
    HIGH = "HIGH"            # 80-95%
    MEDIUM = "MEDIUM"        # 60-80%
    LOW = "LOW"              # 40-60%
    VERY_LOW = "VERY_LOW"    # <40%

@dataclass
class VulnerabilityPattern:
    """漏洞模式定義"""
    name: str
    patterns: List[str]
    danger_contexts: List[str]
    risk_factors: List[str]
    severity_weights: Dict[str, float]
    confidence_base: float
    description: str
    cwe_mapping: Optional[str] = None
    example_exploit: Optional[str] = None

@dataclass
class PotentialVulnerability:
    """潛在漏洞結果"""
    vulnerability_type: VulnerabilityType
    pattern_matched: str
    confidence: float
    severity_level: SeverityLevel
    location: str
    line_numbers: List[int]
    context: str
    danger_level: str
    risk_factors: List[str]
    pattern_frequency: int
    context_analysis: Dict[str, Any]
    mitigation_hints: List[str]
    exploit_scenario: Optional[str] = None
    related_patterns: List[str] = None

class VulnerabilityGenerator:
    """
    漏洞生成器 - 基於模式識別的潛在漏洞檢測
    
    使用預定義的漏洞模式庫和上下文分析來識別智能合約中的潛在安全問題。
    支援傳統智能合約漏洞檢測和RWA特有的風險識別。
    """
    
    def __init__(self):
        """初始化漏洞生成器"""
        self.vulnerability_patterns = self._init_vulnerability_patterns()
        self.rwa_specific_patterns = self._init_rwa_patterns()
        self.defi_patterns = self._init_defi_patterns()
        self.context_analyzers = self._init_context_analyzers()
        self.severity_calculators = self._init_severity_calculators()
        self.exploit_templates = self._init_exploit_templates()
        
        logger.info("漏洞生成器初始化完成，載入 %d 種漏洞模式", len(self.vulnerability_patterns))
    
    def _init_vulnerability_patterns(self) -> Dict[VulnerabilityType, VulnerabilityPattern]:
        """初始化標準漏洞模式庫"""
        return {
            VulnerabilityType.REENTRANCY: VulnerabilityPattern(
                name="重入攻擊",
                patterns=[
                    r"\.call\s*\(",
                    r"\.send\s*\(",
                    r"\.transfer\s*\(",
                    r"\.delegatecall\s*\(",
                    r"\.call\.value\s*\(",
                    r"\.call\{[^}]*\}\s*\(",
                    r"payable\s*\([^)]*\)\.transfer",
                    r"payable\s*\([^)]*\)\.send"
                ],
                danger_contexts=[
                    r"external\s+",
                    r"public\s+",
                    r"payable\s+",
                    r"msg\.value",
                    r"balance\s*-=",
                    r"balances\[.*\]\s*-=",
                    r"withdraw",
                    r"claim"
                ],
                risk_factors=[
                    "state_change_after_call",
                    "external_call_in_loop",
                    "multiple_calls",
                    "balance_modification",
                    "eth_transfer"
                ],
                severity_weights={
                    "external_call_with_state_change": 0.9,
                    "payable_function": 0.8,
                    "balance_modification": 0.7,
                    "loop_with_external_call": 0.6
                },
                confidence_base=0.7,
                description="檢測可能的重入攻擊漏洞，攻擊者可能在合約狀態更新前重複調用函數",
                cwe_mapping="CWE-362",
                example_exploit="攻擊者創建惡意合約，在receive()函數中再次調用withdraw函數"
            ),
            
            VulnerabilityType.ACCESS_CONTROL: VulnerabilityPattern(
                name="存取控制",
                patterns=[
                    r"onlyOwner",
                    r"onlyAdmin",
                    r"require\s*\(",
                    r"modifier\s+\w+",
                    r"msg\.sender\s*==",
                    r"tx\.origin\s*==",
                    r"owner\s*==",
                    r"_owner\s*==",
                    r"hasRole\s*\(",
                    r"_checkRole\s*\("
                ],
                danger_contexts=[
                    r"selfdestruct",
                    r"delegatecall",
                    r"mint\s*\(",
                    r"burn\s*\(",
                    r"pause\s*\(",
                    r"upgrade",
                    r"withdraw",
                    r"emergency"
                ],
                risk_factors=[
                    "missing_access_control",
                    "weak_authorization",
                    "tx_origin_usage",
                    "admin_functions",
                    "critical_operations"
                ],
                severity_weights={
                    "critical_function_unprotected": 0.95,
                    "tx_origin_vulnerability": 0.8,
                    "weak_access_control": 0.6,
                    "missing_role_check": 0.7
                },
                confidence_base=0.6,
                description="檢測存取控制機制的缺陷，可能導致未授權的特權操作",
                cwe_mapping="CWE-285",
                example_exploit="攻擊者通過繞過權限檢查執行管理員功能"
            ),
            
            VulnerabilityType.INTEGER_OVERFLOW: VulnerabilityPattern(
                name="整數溢位",
                patterns=[
                    r"\+\+",
                    r"--",
                    r"\+=",
                    r"-=",
                    r"\*=",
                    r"/=",
                    r"\s+\+\s+",
                    r"\s+-\s+",
                    r"\s+\*\s+",
                    r"\s+/\s+",
                    r"\*\*",
                    r"unchecked\s*\{"
                ],
                danger_contexts=[
                    r"uint\d*\s+",
                    r"int\d*\s+",
                    r"balance",
                    r"amount",
                    r"supply",
                    r"price",
                    r"value",
                    r"for\s*\(",
                    r"while\s*\("
                ],
                risk_factors=[
                    "unchecked_arithmetic",
                    "user_input_arithmetic",
                    "loop_operations",
                    "large_numbers",
                    "multiplication_first"
                ],
                severity_weights={
                    "balance_overflow": 0.9,
                    "supply_overflow": 0.85,
                    "unchecked_operations": 0.7,
                    "user_controlled_input": 0.8
                },
                confidence_base=0.5,
                description="檢測可能的整數溢位/下溢漏洞，可能導致數值計算錯誤",
                cwe_mapping="CWE-190",
                example_exploit="攻擊者輸入極大數值導致整數溢位，繞過餘額檢查"
            ),
            
            VulnerabilityType.TIMESTAMP_DEPENDENCY: VulnerabilityPattern(
                name="時間戳依賴",
                patterns=[
                    r"block\.timestamp",
                    r"block\.number",
                    r"\bnow\b",
                    r"block\.difficulty",
                    r"blockhash\s*\(",
                    r"block\.coinbase"
                ],
                danger_contexts=[
                    r"require\s*\(",
                    r"if\s*\(",
                    r"random",
                    r"seed",
                    r"lottery",
                    r"game",
                    r"time",
                    r"deadline"
                ],
                risk_factors=[
                    "randomness_source",
                    "time_based_logic",
                    "miner_manipulation",
                    "time_precision",
                    "deadline_logic"
                ],
                severity_weights={
                    "randomness_manipulation": 0.8,
                    "time_logic_manipulation": 0.6,
                    "deadline_bypass": 0.7
                },
                confidence_base=0.6,
                description="檢測對區塊時間戳和區塊參數的不安全依賴",
                cwe_mapping="CWE-367",
                example_exploit="礦工操縱區塊時間戳影響合約邏輯執行結果"
            ),
            
            VulnerabilityType.PRICE_MANIPULATION: VulnerabilityPattern(
                name="價格操縱",
                patterns=[
                    r"getPrice\s*\(",
                    r"oracle",
                    r"price",
                    r"getAmountsOut\s*\(",
                    r"getAmountsIn\s*\(",
                    r"getReserves\s*\(",
                    r"swap\w*\s*\(",
                    r"latestRoundData\s*\(",
                    r"aggregator"
                ],
                danger_contexts=[
                    r"single.*oracle",
                    r"flash.*loan",
                    r"immediate.*price",
                    r"spot.*price",
                    r"DEX",
                    r"AMM",
                    r"liquidity"
                ],
                risk_factors=[
                    "single_oracle_dependency",
                    "flash_loan_vulnerability",
                    "price_deviation",
                    "arbitrage_opportunity",
                    "manipulation_resistance"
                ],
                severity_weights={
                    "single_price_source": 0.8,
                    "flash_loan_attack": 0.9,
                    "price_deviation_large": 0.75,
                    "no_slippage_protection": 0.7
                },
                confidence_base=0.7,
                description="檢測價格操縱攻擊風險，特別是預言機和DEX價格依賴",
                cwe_mapping="CWE-20",
                example_exploit="攻擊者使用閃電貸操縱DEX價格，影響合約定價邏輯"
            ),
            
            VulnerabilityType.UNCHECKED_CALL: VulnerabilityPattern(
                name="未檢查的外部調用",
                patterns=[
                    r"\.call\s*\(",
                    r"\.send\s*\(",
                    r"\.delegatecall\s*\(",
                    r"\.staticcall\s*\(",
                    r"\.transfer\s*\("
                ],
                danger_contexts=[
                    r"(?<!require\s*\(.*)",  # 不在require中
                    r"(?<!assert\s*\(.*)",   # 不在assert中
                    r"(?<!if\s*\(.*)"       # 不在if條件中
                ],
                risk_factors=[
                    "unchecked_return_value",
                    "external_call_failure",
                    "gas_limitation",
                    "call_stack_depth"
                ],
                severity_weights={
                    "unchecked_send": 0.7,
                    "unchecked_call": 0.8,
                    "unchecked_delegatecall": 0.9
                },
                confidence_base=0.6,
                description="檢測未檢查返回值的外部調用",
                cwe_mapping="CWE-252",
                example_exploit="外部調用失敗但合約繼續執行，導致狀態不一致"
            ),
            
            VulnerabilityType.DENIAL_OF_SERVICE: VulnerabilityPattern(
                name="拒絕服務攻擊",
                patterns=[
                    r"for\s*\([^)]*;\s*[^;]*<[^;]*;\s*[^)]*\)",
                    r"while\s*\([^)]*\)",
                    r"do\s*\{.*\}\s*while",
                    r"gas\s*\(",
                    r"gasleft\s*\(",
                    r"block\.gaslimit"
                ],
                danger_contexts=[
                    r"unbounded.*loop",
                    r"external.*dependency",
                    r"array\.length",
                    r"mapping.*iteration",
                    r"recursive"
                ],
                risk_factors=[
                    "unbounded_loop",
                    "external_dependency",
                    "gas_exhaustion",
                    "resource_consumption",
                    "recursive_calls"
                ],
                severity_weights={
                    "unbounded_operations": 0.8,
                    "external_dos": 0.7,
                    "gas_limit_dos": 0.6
                },
                confidence_base=0.5,
                description="檢測可能導致拒絕服務攻擊的代碼模式",
                cwe_mapping="CWE-400",
                example_exploit="攻擊者觸發消耗大量gas的操作，使合約無法正常執行"
            ),
            
            VulnerabilityType.FLASH_LOAN: VulnerabilityPattern(
                name="閃電貸攻擊",
                patterns=[
                    r"flashLoan\s*\(",
                    r"borrow\s*\(",
                    r"loan\s*\(",
                    r"flash\w*\s*\(",
                    r"onFlashLoan\s*\(",
                    r"executeOperation\s*\("
                ],
                danger_contexts=[
                    r"price.*oracle",
                    r"liquidity.*pool",
                    r"arbitrage",
                    r"swap",
                    r"leverage"
                ],
                risk_factors=[
                    "flash_loan_availability",
                    "price_manipulation_risk",
                    "atomic_transaction",
                    "leverage_abuse"
                ],
                severity_weights={
                    "price_oracle_manipulation": 0.9,
                    "liquidity_abuse": 0.8,
                    "arbitrage_attack": 0.7
                },
                confidence_base=0.8,
                description="檢測閃電貸相關的攻擊風險",
                cwe_mapping="CWE-691",
                example_exploit="攻擊者使用閃電貸獲得大量資金，操縱市場價格獲利"
            ),
            
            VulnerabilityType.FRONT_RUNNING: VulnerabilityPattern(
                name="搶跑攻擊",
                patterns=[
                    r"transaction.*order",
                    r"mempool",
                    r"pending.*transaction",
                    r"commit.*reveal",
                    r"secret.*hash"
                ],
                danger_contexts=[
                    r"auction",
                    r"bid",
                    r"order",
                    r"trade",
                    r"arbitrage"
                ],
                risk_factors=[
                    "transaction_ordering",
                    "mempool_visibility",
                    "mev_opportunity",
                    "value_extraction"
                ],
                severity_weights={
                    "high_value_transaction": 0.8,
                    "auction_mechanism": 0.7,
                    "trading_logic": 0.6
                },
                confidence_base=0.6,
                description="檢測搶跑攻擊和MEV風險",
                cwe_mapping="CWE-367"
            ),
            
            VulnerabilityType.GOVERNANCE_ATTACK: VulnerabilityPattern(
                name="治理攻擊",
                patterns=[
                    r"vote\s*\(",
                    r"proposal\s*\(",
                    r"governance",
                    r"delegate\s*\(",
                    r"quorum",
                    r"timelock"
                ],
                danger_contexts=[
                    r"admin.*control",
                    r"parameter.*change",
                    r"upgrade.*proxy",
                    r"emergency.*pause"
                ],
                risk_factors=[
                    "governance_concentration",
                    "flash_loan_voting",
                    "proposal_manipulation",
                    "admin_key_risk"
                ],
                severity_weights={
                    "concentrated_voting_power": 0.8,
                    "flash_loan_governance": 0.9,
                    "admin_override": 0.7
                },
                confidence_base=0.7,
                description="檢測治理機制相關的攻擊風險",
                cwe_mapping="CWE-285"
            )
        }
    
    def _init_rwa_patterns(self) -> Dict[str, VulnerabilityPattern]:
        """初始化RWA特定漏洞模式"""
        return {
            "asset_verification": VulnerabilityPattern(
                name="資產驗證風險",
                patterns=[
                    r"custody",
                    r"proof",
                    r"verification",
                    r"audit",
                    r"appraisal",
                    r"valuation"
                ],
                danger_contexts=[
                    r"single.*custodian",
                    r"unverified.*asset",
                    r"outdated.*valuation",
                    r"insufficient.*audit"
                ],
                risk_factors=[
                    "custody_centralization",
                    "verification_gaps",
                    "valuation_outdated",
                    "audit_insufficient"
                ],
                severity_weights={
                    "single_point_failure": 0.8,
                    "unverified_backing": 0.9,
                    "outdated_valuation": 0.6
                },
                confidence_base=0.7,
                description="RWA資產驗證和託管風險",
                cwe_mapping="CWE-345"
            ),
            
            "compliance_violation": VulnerabilityPattern(
                name="合規性違規",
                patterns=[
                    r"kyc",
                    r"aml",
                    r"accredited.*investor",
                    r"regulatory.*compliance",
                    r"jurisdiction"
                ],
                danger_contexts=[
                    r"missing.*kyc",
                    r"insufficient.*compliance",
                    r"regulatory.*gap",
                    r"jurisdiction.*conflict"
                ],
                risk_factors=[
                    "regulatory_non_compliance",
                    "kyc_gaps",
                    "jurisdiction_issues",
                    "legal_exposure"
                ],
                severity_weights={
                    "regulatory_violation": 0.8,
                    "kyc_insufficient": 0.7,
                    "legal_risk": 0.6
                },
                confidence_base=0.6,
                description="RWA合規性相關風險",
                cwe_mapping="CWE-693"
            ),
            
            "cross_chain_risk": VulnerabilityPattern(
                name="跨鏈風險",
                patterns=[
                    r"bridge",
                    r"cross.*chain",
                    r"multi.*chain",
                    r"relay",
                    r"validator"
                ],
                danger_contexts=[
                    r"bridge.*exploit",
                    r"validator.*compromise",
                    r"cross.*chain.*attack",
                    r"relay.*manipulation"
                ],
                risk_factors=[
                    "bridge_centralization",
                    "validator_risk",
                    "cross_chain_communication",
                    "finality_issues"
                ],
                severity_weights={
                    "bridge_vulnerability": 0.9,
                    "validator_compromise": 0.8,
                    "finality_attack": 0.7
                },
                confidence_base=0.8,
                description="跨鏈橋接相關風險",
                cwe_mapping="CWE-346"
            )
        }
    
    def _init_defi_patterns(self) -> Dict[str, VulnerabilityPattern]:
        """初始化DeFi特定漏洞模式"""
        return {
            "sandwich_attack": VulnerabilityPattern(
                name="夾子攻擊",
                patterns=[
                    r"swap\w*\s*\(",
                    r"slippage",
                    r"deadline",
                    r"amountOutMin",
                    r"amountInMax"
                ],
                danger_contexts=[
                    r"high.*slippage",
                    r"no.*deadline",
                    r"public.*mempool",
                    r"predictable.*trade"
                ],
                risk_factors=[
                    "high_slippage_tolerance",
                    "no_deadline_protection",
                    "mev_opportunity",
                    "predictable_trading"
                ],
                severity_weights={
                    "excessive_slippage": 0.7,
                    "no_mev_protection": 0.8
                },
                confidence_base=0.6,
                description="DeFi夾子攻擊風險",
                cwe_mapping="CWE-362"
            ),
            
            "liquidity_drain": VulnerabilityPattern(
                name="流動性枯竭",
                patterns=[
                    r"liquidity",
                    r"pool",
                    r"reserve",
                    r"drain",
                    r"withdraw.*all"
                ],
                danger_contexts=[
                    r"emergency.*withdraw",
                    r"liquidity.*migration",
                    r"pool.*manipulation",
                    r"reserve.*attack"
                ],
                risk_factors=[
                    "liquidity_concentration",
                    "emergency_withdrawal",
                    "pool_manipulation",
                    "reserve_depletion"
                ],
                severity_weights={
                    "liquidity_monopoly": 0.8,
                    "drain_mechanism": 0.9
                },
                confidence_base=0.7,
                description="流動性枯竭攻擊風險",
                cwe_mapping="CWE-400"
            )
        }
    
    def _init_context_analyzers(self) -> Dict[str, callable]:
        """初始化上下文分析器"""
        return {
            "function_context": self._analyze_function_context,
            "state_change_context": self._analyze_state_change_context,
            "external_call_context": self._analyze_external_call_context,
            "access_control_context": self._analyze_access_control_context,
            "value_flow_context": self._analyze_value_flow_context
        }
    
    def _init_severity_calculators(self) -> Dict[VulnerabilityType, callable]:
        """初始化嚴重性計算器"""
        return {
            VulnerabilityType.REENTRANCY: self._calculate_reentrancy_severity,
            VulnerabilityType.ACCESS_CONTROL: self._calculate_access_control_severity,
            VulnerabilityType.PRICE_MANIPULATION: self._calculate_price_manipulation_severity,
            VulnerabilityType.FLASH_LOAN: self._calculate_flash_loan_severity
        }
    
    def _init_exploit_templates(self) -> Dict[VulnerabilityType, str]:
        """初始化攻擊場景模板"""
        return {
            VulnerabilityType.REENTRANCY: """
攻擊場景：
1. 攻擊者部署惡意合約
2. 調用目標合約的withdraw函數
3. 在receive/fallback函數中重複調用withdraw
4. 在餘額更新前多次提取資金
            """,
            VulnerabilityType.PRICE_MANIPULATION: """
攻擊場景：
1. 攻擊者獲取閃電貸
2. 使用大量資金操縱DEX價格
3. 利用價格差異在目標合約中獲利
4. 歸還閃電貸並保留利潤
            """,
            VulnerabilityType.FLASH_LOAN: """
攻擊場景：
1. 攻擊者發起閃電貸請求
2. 在回調函數中執行複雜操作
3. 利用原子性特性進行套利或操縱
4. 歸還貸款完成攻擊
            """
        }
    
    def generate_vulnerabilities(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """
        生成潛在漏洞列表
        
        Args:
            data: 多模態輸入處理後的數據
            
        Returns:
            潛在漏洞列表
        """
        logger.info("開始生成潛在漏洞...")
        
        vulnerabilities = []
        contract_code = data.get("contract_code", "")
        
        if not contract_code:
            logger.warning("未提供智能合約代碼")
            return vulnerabilities
        
        # 標準智能合約漏洞檢測
        standard_vulnerabilities = self._detect_standard_vulnerabilities(contract_code, data)
        vulnerabilities.extend(standard_vulnerabilities)
        
        # RWA特定漏洞檢測
        rwa_vulnerabilities = self._detect_rwa_vulnerabilities(data)
        vulnerabilities.extend(rwa_vulnerabilities)
        
        # DeFi相關漏洞檢測
        defi_vulnerabilities = self._detect_defi_vulnerabilities(contract_code, data)
        vulnerabilities.extend(defi_vulnerabilities)
        
        # 複雜邏輯漏洞檢測
        logic_vulnerabilities = self._detect_logic_vulnerabilities(data)
        vulnerabilities.extend(logic_vulnerabilities)
        
        # 漏洞關聯性分析
        vulnerabilities = self._analyze_vulnerability_relationships(vulnerabilities)
        
        # 漏洞優先級排序
        vulnerabilities = self._prioritize_vulnerabilities(vulnerabilities)
        
        logger.info("漏洞生成完成，識別出 %d 個潛在漏洞", len(vulnerabilities))
        return vulnerabilities
    
    def _detect_standard_vulnerabilities(self, contract_code: str, 
                                       data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測標準智能合約漏洞"""
        vulnerabilities = []
        
        for vuln_type, pattern_config in self.vulnerability_patterns.items():
            detected_vulns = self._detect_pattern_vulnerabilities(
                contract_code, vuln_type, pattern_config, data
            )
            vulnerabilities.extend(detected_vulns)
        
        return vulnerabilities
    
    def _detect_pattern_vulnerabilities(self, contract_code: str, 
                                      vuln_type: VulnerabilityType,
                                      pattern_config: VulnerabilityPattern,
                                      data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """基於模式檢測特定類型漏洞"""
        vulnerabilities = []
        lines = contract_code.split('\n')
        
        for pattern in pattern_config.patterns:
            matches = list(re.finditer(pattern, contract_code, re.IGNORECASE | re.MULTILINE))
            
            if not matches:
                continue
            
            # 分析每個匹配
            for match in matches:
                line_num = contract_code[:match.start()].count('\n') + 1
                
                # 提取上下文
                context = self._extract_context(lines, line_num, context_size=3)
                
                # 分析危險上下文
                danger_level = self._assess_danger_level(
                    context, pattern_config.danger_contexts
                )
                
                # 識別風險因子
                risk_factors = self._identify_risk_factors(
                    context, pattern_config.risk_factors
                )
                
                # 計算置信度
                confidence = self._calculate_confidence(
                    vuln_type, pattern, context, risk_factors, pattern_config
                )
                
                # 計算嚴重性
                severity = self._calculate_severity(
                    vuln_type, danger_level, risk_factors, pattern_config
                )
                
                # 上下文分析
                context_analysis = self._perform_context_analysis(
                    context, vuln_type, data
                )
                
                # 生成緩解提示
                mitigation_hints = self._generate_mitigation_hints(
                    vuln_type, risk_factors
                )
                
                # 查找相關模式
                related_patterns = self._find_related_patterns(
                    vuln_type, context, contract_code
                )
                
                vulnerability = PotentialVulnerability(
                    vulnerability_type=vuln_type,
                    pattern_matched=pattern,
                    confidence=confidence,
                    severity_level=severity,
                    location=f"Line {line_num}",
                    line_numbers=[line_num],
                    context=context,
                    danger_level=danger_level,
                    risk_factors=risk_factors,
                    pattern_frequency=len(matches),
                    context_analysis=context_analysis,
                    mitigation_hints=mitigation_hints,
                    exploit_scenario=self.exploit_templates.get(vuln_type),
                    related_patterns=related_patterns
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_rwa_vulnerabilities(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測RWA特定漏洞"""
        vulnerabilities = []
        
        # 資產驗證風險
        asset_verification_vulns = self._detect_asset_verification_risks(data)
        vulnerabilities.extend(asset_verification_vulns)
        
        # 合規性風險
        compliance_vulns = self._detect_compliance_risks(data)
        vulnerabilities.extend(compliance_vulns)
        
        # 跨鏈風險
        cross_chain_vulns = self._detect_cross_chain_risks(data)
        vulnerabilities.extend(cross_chain_vulns)
        
        return vulnerabilities
    
    def _detect_asset_verification_risks(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測資產驗證風險"""
        vulnerabilities = []
        
        # 檢查資產驗證率
        verification_rate = data.get("verification_rate", 1.0)
        if verification_rate < 0.9:
            severity = SeverityLevel.HIGH if verification_rate < 0.7 else SeverityLevel.MEDIUM
            confidence = 0.8 if verification_rate < 0.5 else 0.6
            
            vulnerability = PotentialVulnerability(
                vulnerability_type=VulnerabilityType.ASSET_VERIFICATION,
                pattern_matched="low_verification_rate",
                confidence=confidence,
                severity_level=severity,
                location="Asset verification system",
                line_numbers=[],
                context=f"資產驗證率: {verification_rate:.2%}",
                danger_level="HIGH" if verification_rate < 0.7 else "MEDIUM",
                risk_factors=["insufficient_asset_backing", "verification_gaps"],
                pattern_frequency=1,
                context_analysis={
                    "verification_metrics": {
                        "rate": verification_rate,
                        "threshold": 0.9,
                        "gap": 0.9 - verification_rate
                    }
                },
                mitigation_hints=[
                    "提高資產驗證覆蓋率至90%以上",
                    "建立多重驗證機制",
                    "引入第三方審計"
                ]
            )
            vulnerabilities.append(vulnerability)
        
        # 檢查保險覆蓋
        insurance_ratio = data.get("insurance_coverage_ratio", 0)
        if insurance_ratio < 0.8:
            vulnerability = PotentialVulnerability(
                vulnerability_type=VulnerabilityType.ASSET_VERIFICATION,
                pattern_matched="insufficient_insurance",
                confidence=0.7,
                severity_level=SeverityLevel.MEDIUM,
                location="Insurance coverage",
                line_numbers=[],
                context=f"保險覆蓋率: {insurance_ratio:.2%}",
                danger_level="MEDIUM",
                risk_factors=["insufficient_protection", "asset_risk"],
                pattern_frequency=1,
                context_analysis={
                    "insurance_metrics": {
                        "coverage_ratio": insurance_ratio,
                        "recommended_minimum": 0.8
                    }
                },
                mitigation_hints=[
                    "增加保險覆蓋至資產價值的80%以上",
                    "選擇多元化的保險提供商",
                    "建立應急保險基金"
                ]
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_compliance_risks(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測合規性風險"""
        vulnerabilities = []
        
        # 檢查合規評分
        avg_compliance_score = data.get("average_compliance_score", 100)
        if avg_compliance_score < 80:
            severity = SeverityLevel.HIGH if avg_compliance_score < 60 else SeverityLevel.MEDIUM
            confidence = 0.8
            
            vulnerability = PotentialVulnerability(
                vulnerability_type=VulnerabilityType.COMPLIANCE_VIOLATION,
                pattern_matched="low_compliance_score",
                confidence=confidence,
                severity_level=severity,
                location="Legal documentation",
                line_numbers=[],
                context=f"合規評分: {avg_compliance_score}/100",
                danger_level="HIGH" if avg_compliance_score < 60 else "MEDIUM",
                risk_factors=["regulatory_non_compliance", "legal_exposure"],
                pattern_frequency=1,
                context_analysis={
                    "compliance_metrics": {
                        "score": avg_compliance_score,
                        "threshold": 80,
                        "gap": 80 - avg_compliance_score
                    }
                },
                mitigation_hints=[
                    "完善法律合規文檔",
                    "諮詢監管法律專家",
                    "建立合規監控機制"
                ]
            )
            vulnerabilities.append(vulnerability)
        
        # 檢查監管覆蓋
        regulatory_coverage = data.get("regulatory_coverage", {})
        missing_coverage = [k for k, v in regulatory_coverage.items() if not v]
        
        if len(missing_coverage) > 2:
            vulnerability = PotentialVulnerability(
                vulnerability_type=VulnerabilityType.COMPLIANCE_VIOLATION,
                pattern_matched="insufficient_regulatory_coverage",
                confidence=0.7,
                severity_level=SeverityLevel.MEDIUM,
                location="Regulatory framework",
                line_numbers=[],
                context=f"缺失監管覆蓋: {', '.join(missing_coverage)}",
                danger_level="MEDIUM",
                risk_factors=["regulatory_gaps", "compliance_risk"],
                pattern_frequency=len(missing_coverage),
                context_analysis={
                    "coverage_analysis": {
                        "missing_areas": missing_coverage,
                        "coverage_rate": (len(regulatory_coverage) - len(missing_coverage)) / len(regulatory_coverage) if regulatory_coverage else 0
                    }
                },
                mitigation_hints=[
                    "完善監管合規覆蓋",
                    "建立全面的合規框架",
                    "定期更新監管要求"
                ]
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_cross_chain_risks(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測跨鏈風險"""
        vulnerabilities = []
        contract_code = data.get("contract_code", "")
        
        # 檢測跨鏈相關代碼
        cross_chain_patterns = [
            r"bridge",
            r"crossChain",
            r"relay",
            r"validator",
            r"merkleProof"
        ]
        
        for pattern in cross_chain_patterns:
            if re.search(pattern, contract_code, re.IGNORECASE):
                vulnerability = PotentialVulnerability(
                    vulnerability_type=VulnerabilityType.CROSS_CHAIN_BRIDGE,
                    pattern_matched=pattern,
                    confidence=0.6,
                    severity_level=SeverityLevel.MEDIUM,
                    location="Cross-chain implementation",
                    line_numbers=self._find_pattern_lines(contract_code, pattern),
                    context=self._extract_pattern_context(contract_code, pattern),
                    danger_level="MEDIUM",
                    risk_factors=["bridge_risk", "validator_dependency"],
                    pattern_frequency=len(re.findall(pattern, contract_code, re.IGNORECASE)),
                    context_analysis={
                        "cross_chain_analysis": {
                            "pattern": pattern,
                            "complexity": "medium"
                        }
                    },
                    mitigation_hints=[
                        "實施多重驗證機制",
                        "建立跨鏈監控",
                        "使用成熟的跨鏈協議"
                    ]
                )
                vulnerabilities.append(vulnerability)
                break  # 避免重複檢測
        
        return vulnerabilities
    
    def _detect_defi_vulnerabilities(self, contract_code: str, 
                                   data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測DeFi相關漏洞"""
        vulnerabilities = []
        
        for vuln_name, pattern_config in self.defi_patterns.items():
            detected_vulns = self._detect_pattern_vulnerabilities(
                contract_code, 
                VulnerabilityType.SANDWICH_ATTACK if "sandwich" in vuln_name else VulnerabilityType.LIQUIDITY_DRAIN,
                pattern_config, 
                data
            )
            vulnerabilities.extend(detected_vulns)
        
        return vulnerabilities
    
    def _detect_logic_vulnerabilities(self, data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測複雜邏輯漏洞"""
        vulnerabilities = []
        
        contract_code = data.get("contract_code", "")
        functions = data.get("functions", [])
        
        # 檢測未保護的關鍵函數
        critical_function_vulns = self._detect_unprotected_critical_functions(functions)
        vulnerabilities.extend(critical_function_vulns)
        
        # 檢測複雜狀態變更
        state_change_vulns = self._detect_complex_state_changes(contract_code)
        vulnerabilities.extend(state_change_vulns)
        
        # 檢測業務邏輯錯誤
        business_logic_vulns = self._detect_business_logic_errors(contract_code, data)
        vulnerabilities.extend(business_logic_vulns)
        
        return vulnerabilities
    
    def _detect_unprotected_critical_functions(self, functions: List[Dict]) -> List[PotentialVulnerability]:
        """檢測未保護的關鍵函數"""
        vulnerabilities = []
        
        for func in functions:
            if self._is_critical_function(func) and not self._has_access_protection(func):
                vulnerability = PotentialVulnerability(
                    vulnerability_type=VulnerabilityType.ACCESS_CONTROL,
                    pattern_matched="unprotected_critical_function",
                    confidence=0.9,
                    severity_level=SeverityLevel.HIGH,
                    location=f"Line {func.get('line_number', 0)}",
                    line_numbers=[func.get('line_number', 0)],
                    context=func.get('signature', ''),
                    danger_level="HIGH",
                    risk_factors=["unauthorized_access", "privilege_escalation"],
                    pattern_frequency=1,
                    context_analysis={
                        "function_analysis": {
                            "name": func.get('name', ''),
                            "visibility": func.get('visibility', ''),
                            "modifiers": func.get('modifiers', [])
                        }
                    },
                    mitigation_hints=[
                        "添加適當的存取控制修飾符",
                        "實施基於角色的權限管理",
                        "添加多重簽名保護"
                    ]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    # ========== 輔助方法 ==========
    
    def _extract_context(self, lines: List[str], line_num: int, context_size: int = 3) -> str:
        """提取指定行的上下文"""
        start = max(0, line_num - context_size - 1)
        end = min(len(lines), line_num + context_size)
        return '\n'.join(lines[start:end])
    
    def _assess_danger_level(self, context: str, danger_contexts: List[str]) -> str:
        """評估危險等級"""
        danger_score = 0
        context_lower = context.lower()
        
        for danger_pattern in danger_contexts:
            if re.search(danger_pattern, context_lower):
                danger_score += 1
        
        if danger_score >= 3:
            return "CRITICAL"
        elif danger_score >= 2:
            return "HIGH"
        elif danger_score >= 1:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _identify_risk_factors(self, context: str, risk_factors: List[str]) -> List[str]:
        """識別風險因子"""
        identified = []
        context_lower = context.lower()
        
        for risk_factor in risk_factors:
            keywords = risk_factor.split('_')
            if all(keyword in context_lower for keyword in keywords):
                identified.append(risk_factor)
        
        return identified
    
    def _calculate_confidence(self, vuln_type: VulnerabilityType, pattern: str, 
                            context: str, risk_factors: List[str],
                            pattern_config: VulnerabilityPattern) -> float:
        """計算置信度"""
        base_confidence = pattern_config.confidence_base
        
        # 基於風險因子調整
        risk_boost = len(risk_factors) * 0.1
        
        # 基於上下文相關性調整
        context_boost = 0
        for danger_context in pattern_config.danger_contexts:
            if re.search(danger_context, context, re.IGNORECASE):
                context_boost += 0.05
        
        # 基於模式特定性調整
        pattern_boost = 0.1 if len(pattern) > 10 else 0.05
        
        final_confidence = min(base_confidence + risk_boost + context_boost + pattern_boost, 0.99)
        return final_confidence
    
    def _calculate_severity(self, vuln_type: VulnerabilityType, danger_level: str, 
                          risk_factors: List[str], pattern_config: VulnerabilityPattern) -> SeverityLevel:
        """計算嚴重性等級"""
        # 使用特定計算器（如果存在）
        if vuln_type in self.severity_calculators:
            return self.severity_calculators[vuln_type](danger_level, risk_factors, pattern_config)
        
        # 默認計算邏輯
        base_severity = {
            "CRITICAL": SeverityLevel.CRITICAL,
            "HIGH": SeverityLevel.HIGH,
            "MEDIUM": SeverityLevel.MEDIUM,
            "LOW": SeverityLevel.LOW
        }.get(danger_level, SeverityLevel.LOW)
        
        # 基於風險因子調整
        if len(risk_factors) >= 3:
            if base_severity == SeverityLevel.MEDIUM:
                return SeverityLevel.HIGH
            elif base_severity == SeverityLevel.LOW:
                return SeverityLevel.MEDIUM
        
        return base_severity
    
    def _perform_context_analysis(self, context: str, vuln_type: VulnerabilityType, 
                                 data: Dict[str, Any]) -> Dict[str, Any]:
        """執行上下文分析"""
        analysis = {
            "context_length": len(context),
            "complexity_indicators": len(re.findall(r'[{}();]', context)),
            "external_calls": len(re.findall(r'\.call\s*\(|\.send\s*\(|\.transfer\s*\(', context)),
            "state_changes": len(re.findall(r'=\s*[^=]', context))
        }
        
        # 添加特定分析器結果
        for analyzer_name, analyzer_func in self.context_analyzers.items():
            try:
                analysis[analyzer_name] = analyzer_func(context, vuln_type, data)
            except Exception as e:
                logger.warning(f"上下文分析器 {analyzer_name} 執行失敗: {e}")
        
        return analysis
    
    def _generate_mitigation_hints(self, vuln_type: VulnerabilityType, 
                                 risk_factors: List[str]) -> List[str]:
        """生成緩解建議"""
        base_hints = {
            VulnerabilityType.REENTRANCY: [
                "使用OpenZeppelin的ReentrancyGuard",
                "採用Checks-Effects-Interactions模式",
                "避免在外部調用後修改狀態"
            ],
            VulnerabilityType.ACCESS_CONTROL: [
                "實施基於角色的存取控制",
                "使用OpenZeppelin的AccessControl",
                "避免使用tx.origin進行授權"
            ],
            VulnerabilityType.PRICE_MANIPULATION: [
                "使用多個價格預言機",
                "實施時間加權平均價格(TWAP)",
                "添加價格偏差檢查"
            ]
        }
        
        hints = base_hints.get(vuln_type, ["諮詢安全專家進行詳細分析"])
        
        # 基於風險因子添加特定建議
        if "flash_loan" in risk_factors:
            hints.append("實施閃電貸保護機制")
        if "single_oracle" in risk_factors:
            hints.append("使用多重預言機驗證")
        
        return hints
    
    def _find_related_patterns(self, vuln_type: VulnerabilityType, 
                              context: str, contract_code: str) -> List[str]:
        """查找相關模式"""
        related = []
        
        # 基於漏洞類型查找相關模式
        related_patterns_map = {
            VulnerabilityType.REENTRANCY: ["external_call", "state_change", "eth_transfer"],
            VulnerabilityType.PRICE_MANIPULATION: ["oracle_usage", "swap_function", "price_calculation"],
            VulnerabilityType.ACCESS_CONTROL: ["admin_function", "privilege_check", "role_assignment"]
        }
        
        patterns = related_patterns_map.get(vuln_type, [])
        for pattern in patterns:
            if pattern in context.lower() or pattern in contract_code.lower():
                related.append(pattern)
        
        return related
    
    def _analyze_vulnerability_relationships(self, vulnerabilities: List[PotentialVulnerability]) -> List[PotentialVulnerability]:
        """分析漏洞間的關聯性"""
        # 檢測漏洞組合可能產生的複合攻擊
        vulnerability_map = defaultdict(list)
        
        for vuln in vulnerabilities:
            vulnerability_map[vuln.vulnerability_type].append(vuln)
        
        # 標記相關漏洞
        for vuln in vulnerabilities:
            if vuln.vulnerability_type == VulnerabilityType.REENTRANCY:
                # 檢查是否存在存取控制問題
                if VulnerabilityType.ACCESS_CONTROL in vulnerability_map:
                    vuln.related_patterns = vuln.related_patterns or []
                    vuln.related_patterns.append("access_control_weakness")
                    vuln.confidence = min(vuln.confidence + 0.1, 0.99)
        
        return vulnerabilities
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[PotentialVulnerability]) -> List[PotentialVulnerability]:
        """漏洞優先級排序"""
        severity_order = {
            SeverityLevel.CRITICAL: 5,
            SeverityLevel.HIGH: 4,
            SeverityLevel.MEDIUM: 3,
            SeverityLevel.LOW: 2,
            SeverityLevel.INFO: 1
        }
        
        def sort_key(vuln):
            return (
                severity_order.get(vuln.severity_level, 0),
                vuln.confidence,
                len(vuln.risk_factors)
            )
        
        return sorted(vulnerabilities, key=sort_key, reverse=True)
    
    # ========== 特定計算器方法 ==========
    
    def _calculate_reentrancy_severity(self, danger_level: str, risk_factors: List[str],
                                     pattern_config: VulnerabilityPattern) -> SeverityLevel:
        """計算重入攻擊嚴重性"""
        if "eth_transfer" in risk_factors and "state_change_after_call" in risk_factors:
            return SeverityLevel.CRITICAL
        elif "external_call_in_loop" in risk_factors:
            return SeverityLevel.HIGH
        elif danger_level in ["HIGH", "CRITICAL"]:
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.MEDIUM
    
    def _calculate_access_control_severity(self, danger_level: str, risk_factors: List[str],
                                         pattern_config: VulnerabilityPattern) -> SeverityLevel:
        """計算存取控制嚴重性"""
        if "critical_operations" in risk_factors and "missing_access_control" in risk_factors:
            return SeverityLevel.CRITICAL
        elif "admin_functions" in risk_factors:
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.MEDIUM
    
    def _calculate_price_manipulation_severity(self, danger_level: str, risk_factors: List[str],
                                             pattern_config: VulnerabilityPattern) -> SeverityLevel:
        """計算價格操縱嚴重性"""
        if "flash_loan_vulnerability" in risk_factors:
            return SeverityLevel.CRITICAL
        elif "single_oracle_dependency" in risk_factors:
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.MEDIUM
    
    def _calculate_flash_loan_severity(self, danger_level: str, risk_factors: List[str],
                                     pattern_config: VulnerabilityPattern) -> SeverityLevel:
        """計算閃電貸攻擊嚴重性"""
        if "price_manipulation_risk" in risk_factors:
            return SeverityLevel.CRITICAL
        elif "leverage_abuse" in risk_factors:
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.MEDIUM
    
    # ========== 上下文分析器方法 ==========
    
    def _analyze_function_context(self, context: str, vuln_type: VulnerabilityType, 
                                 data: Dict[str, Any]) -> Dict[str, Any]:
        """分析函數上下文"""
        return {
            "has_external_calls": bool(re.search(r'\.call\s*\(|\.send\s*\(', context)),
            "has_state_changes": bool(re.search(r'=\s*[^=]', context)),
            "is_payable": "payable" in context,
            "visibility": self._extract_function_visibility(context)
        }
    
    def _analyze_state_change_context(self, context: str, vuln_type: VulnerabilityType,
                                    data: Dict[str, Any]) -> Dict[str, Any]:
        """分析狀態變更上下文"""
        return {
            "state_variables_modified": len(re.findall(r'\w+\s*=', context)),
            "mapping_access": bool(re.search(r'\w+\[.*\]', context)),
            "balance_modification": bool(re.search(r'balance.*=', context, re.IGNORECASE))
        }
    
    def _analyze_external_call_context(self, context: str, vuln_type: VulnerabilityType,
                                     data: Dict[str, Any]) -> Dict[str, Any]:
        """分析外部調用上下文"""
        return {
            "call_types": re.findall(r'\.(call|send|transfer|delegatecall)\s*\(', context),
            "return_value_checked": bool(re.search(r'require\s*\(.*\.call', context)),
            "in_loop": bool(re.search(r'for\s*\(.*\{.*\.call', context, re.DOTALL))
        }
    
    def _analyze_access_control_context(self, context: str, vuln_type: VulnerabilityType,
                                      data: Dict[str, Any]) -> Dict[str, Any]:
        """分析存取控制上下文"""
        return {
            "has_modifiers": bool(re.search(r'modifier\s+\w+', context)),
            "has_require": bool(re.search(r'require\s*\(', context)),
            "uses_msg_sender": bool(re.search(r'msg\.sender', context)),
            "uses_tx_origin": bool(re.search(r'tx\.origin', context))
        }
    
    def _analyze_value_flow_context(self, context: str, vuln_type: VulnerabilityType,
                                  data: Dict[str, Any]) -> Dict[str, Any]:
        """分析價值流動上下文"""
        return {
            "has_value_transfer": bool(re.search(r'\.transfer\s*\(|\.send\s*\(', context)),
            "has_balance_check": bool(re.search(r'balance.*>=|balance.*>', context)),
            "msg_value_usage": bool(re.search(r'msg\.value', context))
        }
    
    # ========== 其他輔助方法 ==========
    
    def _find_pattern_lines(self, contract_code: str, pattern: str) -> List[int]:
        """查找模式匹配的行號"""
        lines = contract_code.split('\n')
        line_numbers = []
        
        for i, line in enumerate(lines):
            if re.search(pattern, line, re.IGNORECASE):
                line_numbers.append(i + 1)
        
        return line_numbers
    
    def _extract_pattern_context(self, contract_code: str, pattern: str, context_size: int = 2) -> str:
        """提取模式的上下文"""
        lines = contract_code.split('\n')
        
        for i, line in enumerate(lines):
            if re.search(pattern, line, re.IGNORECASE):
                start = max(0, i - context_size)
                end = min(len(lines), i + context_size + 1)
                return '\n'.join(lines[start:end])
        
        return ""
    
    def _is_critical_function(self, func: Dict) -> bool:
        """判斷是否為關鍵函數"""
        if not isinstance(func, dict):
            return False
            
        name = func.get('name', '').lower()
        signature = func.get('signature', '').lower()
        
        critical_keywords = [
            'mint', 'burn', 'transfer', 'withdraw', 'deposit',
            'pause', 'unpause', 'upgrade', 'destroy', 'selfdestruct',
            'owner', 'admin', 'emergency', 'rescue', 'migrate'
        ]
        
        return any(keyword in name or keyword in signature for keyword in critical_keywords)
    
    def _has_access_protection(self, func: Dict) -> bool:
        """檢查函數是否有存取保護"""
        if not isinstance(func, dict):
            return False
            
        modifiers = func.get('modifiers', [])
        signature = func.get('signature', '').lower()
        
        protection_indicators = [
            'onlyowner', 'onlyadmin', 'require', 'hasrole',
            'checkrole', 'authorized', 'permitted'
        ]
        
        # 檢查修飾符
        for modifier in modifiers:
            if any(indicator in modifier.lower() for indicator in protection_indicators):
                return True
        
        # 檢查函數簽名
        return any(indicator in signature for indicator in protection_indicators)
    
    def _extract_function_visibility(self, context: str) -> str:
        """提取函數可見性"""
        visibilities = ['public', 'private', 'internal', 'external']
        for visibility in visibilities:
            if visibility in context.lower():
                return visibility
        return 'unknown'
    
    def _detect_complex_state_changes(self, contract_code: str) -> List[PotentialVulnerability]:
        """檢測複雜的狀態變更"""
        vulnerabilities = []
        
        # 查找複雜的狀態變更模式
        complex_patterns = [
            r'mapping\s*\([^)]+\)\s*\[[^\]]+\]\s*=.*\.call\s*\(',
            r'balance\s*\[[^\]]+\]\s*[+-]=.*\.call\s*\(',
            r'for\s*\([^)]*\)\s*\{[^}]*mapping\s*\[[^\]]+\]\s*='
        ]
        
        for pattern in complex_patterns:
            matches = list(re.finditer(pattern, contract_code, re.IGNORECASE | re.DOTALL))
            
            for match in matches:
                line_num = contract_code[:match.start()].count('\n') + 1
                
                vulnerability = PotentialVulnerability(
                    vulnerability_type=VulnerabilityType.REENTRANCY,
                    pattern_matched="complex_state_changes",
                    confidence=0.6,
                    severity_level=SeverityLevel.MEDIUM,
                    location=f"Line {line_num}",
                    line_numbers=[line_num],
                    context=match.group(),
                    danger_level="MEDIUM",
                    risk_factors=["state_inconsistency", "race_condition"],
                    pattern_frequency=1,
                    context_analysis={
                        "complexity": "high",
                        "state_changes": True,
                        "external_calls": True
                    },
                    mitigation_hints=[
                        "使用Checks-Effects-Interactions模式",
                        "避免在外部調用後修改狀態",
                        "考慮使用狀態鎖定機制"
                    ]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_business_logic_errors(self, contract_code: str, 
                                    data: Dict[str, Any]) -> List[PotentialVulnerability]:
        """檢測業務邏輯錯誤"""
        vulnerabilities = []
        
        # 檢測常見的業務邏輯問題
        logic_patterns = {
            "division_before_multiplication": r'\s*/\s*\d+\s*\*',
            "unsafe_type_conversion": r'uint\d+\s*\(\s*-\d+',
            "incorrect_comparison": r'=\s*(?!=)',  # 可能的賦值錯誤
            "missing_zero_check": r'\/\s*\w+\s*[;}]'  # 除法未檢查零值
        }
        
        for error_type, pattern in logic_patterns.items():
            matches = list(re.finditer(pattern, contract_code))
            
            for match in matches:
                line_num = contract_code[:match.start()].count('\n') + 1
                
                vulnerability = PotentialVulnerability(
                    vulnerability_type=VulnerabilityType.INTEGER_OVERFLOW,  # 或其他適當類型
                    pattern_matched=error_type,
                    confidence=0.4,  # 業務邏輯錯誤置信度較低
                    severity_level=SeverityLevel.LOW,
                    location=f"Line {line_num}",
                    line_numbers=[line_num],
                    context=match.group(),
                    danger_level="LOW",
                    risk_factors=["logic_error", "calculation_error"],
                    pattern_frequency=1,
                    context_analysis={
                        "error_type": error_type,
                        "needs_review": True
                    },
                    mitigation_hints=[
                        "仔細檢查業務邏輯實現",
                        "添加適當的輸入驗證",
                        "進行全面的單元測試"
                    ]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def get_generator_statistics(self) -> Dict[str, Any]:
        """獲取生成器統計信息"""
        return {
            "total_vulnerability_patterns": len(self.vulnerability_patterns),
            "rwa_specific_patterns": len(self.rwa_specific_patterns),
            "defi_patterns": len(self.defi_patterns),
            "context_analyzers": len(self.context_analyzers),
            "severity_calculators": len(self.severity_calculators),
            "supported_vulnerability_types": [vt.value for vt in VulnerabilityType],
            "version": "1.0.0",
            "last_updated": datetime.now().isoformat()
        }

# 使用範例
if __name__ == "__main__":
    generator = VulnerabilityGenerator()
    
    # 顯示生成器統計信息
    stats = generator.get_generator_statistics()
    print("漏洞生成器統計信息:")
    print(json.dumps(stats, indent=2, ensure_ascii=False))