# vulnerability_discriminator.py
# 漏洞判別器模組 - 基於LLM的RWA智能合約安全檢核

import logging
import json
import numpy as np
from datetime import datetime
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum

# 日誌設置
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

@dataclass
class SecurityFinding:
    vulnerability_type: str
    severity: str
    confidence: float
    location: str
    description: str
    recommendation: str
    cwe_id: str
    timestamp: str
    context: str

class VulnerabilityDiscriminator:
    """
    過濾誤報並評估潛在漏洞的真實性，生成最終安全發現
    """
    def __init__(self):
        # 誤報過濾關鍵詞
        self.false_positive_patterns = {"test", "mock", "example", "demo", "template"}
        # CWE映射
        self.cwe_mapping = {
            "重入攻擊": "CWE-362",
            "整數溢位": "CWE-190",
            "存取控制": "CWE-285",
            "時間戳依賴": "CWE-367",
            "價格操縱": "CWE-20",
            "合規性違反": "CWE-693",
            "資產驗證": "CWE-345",
            "未檢查的外部調用": "CWE-252",
            "拒絕服務攻擊": "CWE-400",
            "閃電貸攻擊": "CWE-691",
            "搶跑攻擊": "CWE-694",
            "夾子攻擊": "CWE-362",
            "MEV攻擊": "CWE-362",
            "跨鏈橋接": "CWE-346",
            "治理攻擊": "CWE-285",
            "流動性枯竭": "CWE-400"
        }
        logger.info("漏洞判別器初始化完成")

    def verify_vulnerabilities(self, potential_vulns: List[Dict[str, Any]]) -> List[SecurityFinding]:
        findings = []
        for v in potential_vulns:
            context = v.get("context", "").lower()
            # 誤報過濾
            if any(fp in context for fp in self.false_positive_patterns): continue
            if v.get("confidence", 0) < 0.3: continue
            # 置信度調整
            confidence = self._adjust_confidence(v)
            # 嚴重性評估
            severity = self._assess_severity(v, confidence)
            # 描述與建議
            description = self._generate_description(v)
            recommendation = self._generate_recommendation(v)
            # CWE ID
            cwe_id = self.cwe_mapping.get(v["vulnerability_type"], "Unknown")
            findings.append(SecurityFinding(
                vulnerability_type=v["vulnerability_type"],
                severity=severity,
                confidence=round(confidence, 3),
                location=v.get("location", "Unknown"),
                description=description,
                recommendation=recommendation,
                cwe_id=cwe_id,
                timestamp=datetime.now().isoformat(),
                context=v.get("context", "")
            ))
        # 排序
        findings.sort(key=lambda f: (SeverityLevel[f.severity].value, f.confidence), reverse=True)
        logger.info(f"漏洞判別完成，最終發現 {len(findings)} 個問題")
        return findings

    def _adjust_confidence(self, v: Dict[str, Any]) -> float:
        base = v.get("confidence", 0.5)
        risk_boost = len(v.get("risk_factors", [])) * 0.05
        context_len = len(v.get("context", ""))
        context_boost = 0.05 if context_len > 200 else 0
        return min(base + risk_boost + context_boost, 0.99)

    def _assess_severity(self, v: Dict[str, Any], conf: float) -> str:
        vt = v["vulnerability_type"]
        # 類型與置信度共同決定
        if vt in {"重入攻擊", "閃電貸攻擊"}:
            return SeverityLevel.CRITICAL.value if conf > 0.9 else SeverityLevel.HIGH.value
        if vt in {"價格操縱", "治理攻擊"}:
            return SeverityLevel.HIGH.value if conf > 0.8 else SeverityLevel.MEDIUM.value
        # 默認
        if conf > 0.8: return SeverityLevel.HIGH.value
        if conf > 0.5: return SeverityLevel.MEDIUM.value
        return SeverityLevel.LOW.value

    def _generate_description(self, v: Dict[str, Any]) -> str:
        vt, p = v["vulnerability_type"], v.get("pattern_matched", "")
        desc_map = {
            "重入攻擊": f"發現重入攻擊模式: {p}",
            "整數溢位": f"發現整數溢位風險: {p}",
            "存取控制": f"檢測存取控制缺陷: {p}",
            "價格操縱": f"檢測價格操縱風險: {p}",
            "合規性違反": f"檢測合規性缺失: {p}",
            "資產驗證": f"發現資產驗證不足: {p}",
            "跨鏈橋接": f"檢測跨鏈橋接風險: {p}",
            "閃電貸攻擊": f"檢測閃電貸攻擊: {p}",
            "搶跑攻擊": f"檢測搶跑/MEV風險: {p}",
            "未檢查的外部調用": f"發現未檢查外部調用: {p}",
            "拒絕服務攻擊": f"檢測拒絕服務風險: {p}"
        }
        return desc_map.get(vt, f"發現漏洞: {p}")

    def _generate_recommendation(self, v: Dict[str, Any]) -> str:
        vt = v["vulnerability_type"]
        rec_map = {
            "重入攻擊": "使用ReentrancyGuard或Checks-Effects-Interactions",
            "整數溢位": "升級Solidity至0.8+或使用SafeMath",
            "存取控制": "使用AccessControl並限制管理員權限",
            "價格操縱": "使用多預言機與TWAP",
            "合規性違反": "增強KYC/AML流程並諮詢法律專家",
            "資產驗證": "增加多方託管與第三方審計",
            "跨鏈橋接": "採用成熟跨鏈協議並增加監控",
            "閃電貸攻擊": "實施閃電貸保護機制",
            "搶跑攻擊": "使用交易隱蔽技術或拍賣機制",
            "未檢查的外部調用": "檢查返回值並使用require/assert",
            "拒絕服務攻擊": "限制迴圈次數並實施熔斷"
        }
        return rec_map.get(vt, "諮詢安全專家進行修復")

    def get_discriminator_info(self) -> Dict[str, Any]:
        return {
            "false_positive_patterns": list(self.false_positive_patterns),
            "severity_levels": [s.value for s in SeverityLevel],
            "cwe_mapping_count": len(self.cwe_mapping),
            "version": "1.0.0",
            "last_updated": datetime.now().isoformat()
        }

# 測試
if __name__ == "__main__":
    disc = VulnerabilityDiscriminator()
    info = disc.get_discriminator_info()
    print("漏洞判別器配置信息:\n", json.dumps(info, indent=2, ensure_ascii=False))
